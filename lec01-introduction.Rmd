---
title: "Introduction to course"
---

```{r echo=FALSE, results='hide', message=FALSE, warning=FALSE}
# Load this before class starts
library(tidyverse)
library(GGally)
```

# Working with computers
Before we get into more practical matters, I want to provide a brief background to the idea of working with computers. Essentially, computer work is about humans communicating with the computer by modulating flows of current in the hardware, to get the computer to carry out an advanced calculation that we are unable to compute efficient ourselves. Early examples of human computer communication was quite primitive and included actually disconnecting a wire and connecting it again in a different spot. Luckily, we are not doing this anymore, instead we have programs with graphical user interface with menus and buttons, that enables more efficient human to computer communication.

## Graphical spreadsheet software
An example of such a program that I think many of you are familiar with, is spreadsheet software such as Microsoft Excel and LibreOffice Calc. Here, all the functionality of the program is accessible via hierarchical menus, and clicking buttons send instructions to the computer, which responds and sends the results back to your screen. E.g. I can click this button to send the instruction of coloring this cell yellow, and the computer interprets my instructions and then displays the results on the screen, in this case, the cell is highlighted yellow.

Spreadsheet software is great for viewing and entering small data sets and creating simple visualizations fast. However, it can be tricky to design publication-ready figures, create automatic reproducible analysis workflow, perform advanced calculations, and clean data sets robustly. Even when using a spreadsheet program to record data, it is often beneficial to pick up some basic programming skills to facilitate the analyses of that data.

An more robust and efficient way of communicating with your computer is to type instructions instead of clicking buttons. In programming languages, such as R which we will be using in this class, we can type the name of functions directly instead of finding them in a graphical menu hierarchy. Initially this might seem intimidating and non-intuitive for people who are used to the menu-driven approach. However, think of it as learning a new natural language. Initially, you will slowly string together sentences by looking up individual words in the dictionary. As you improve, you will only reference the dictionary occasionally since you already know most of the words, and eventually you will throw it out because it is faster and more precise to speak directly. Graphical programs force you to look up every word in the dictionary, even if you know what to say.

## Formal and informal languages
You might think it is quite tricky to learn computer languages, but it is actually not! You already know one, mathematics is often written the same way as you would write it by hand, both in Excel and R.

```{r}
d = 4 + 5
```

This is much more efficient than typing "Hi computer, could you please add 4 and 5 for me?". Formal computer languages also avoids the ambiguity present in natural languages such as English. You can think of R as a combination of math and a formal, succinct version of English.

E.g. Create a sequence of the numbers zero to thirty.
```{r}
seq(0, 30)
```

E.g. Create a sequence of the numbers zero to thirty and calculate the average value of this sequence.

```{r}
mean(seq(0, 30))
```

This is not as rich as the English language, which actually is something I am grateful for as an international student. There are few exceptions to the rules, and you rarely have to remember illogical grammar just because "that is how it is", I love it!

And if you think it sounds complicated to remember all of these functions by heart, don't worry there are several places to get help. The one I use the most is called tab-complete: often I remember the beginning of the function I want to use, but I don't remember exactly what it was called. For example, if I want to compute the median of a set of numbers, and I don't remember if the function for this was just `med` or `median`, I can just type the first three letters, hit tab <!-- Technically twice by default in the console, but since it is once in Rstudio, lets skip that distinction -->  and all functions starting with those letters. Here I can see that it is probably `median` I want to use, and to be sure I can type `?median` and read what it does. I will show you way to read these help pages with some nicer formatting later in this lecture. <!-- What's the difference between just `sum`, `mean`, etc and `sum.default`, `mean.deafault`, etc? -->

In my experience, learning programming really is similar to learning a foreign language - you will often learn the most from just trying to do something and receiving feedback (from the computer or another person)! When there is something you can't wrap you head around, or if you are actively trying to find a new way of expressing a thought, then look it up, just as you would with a natural language.

# Programming basics
With that background to some of the concepts of programming, let's compare the workflow of analyzing a data set in R vs in a Excel. _Pull up Excel and R console next to each other._ In Excel, we open a file via 'File -> Open -> Navigate to file'. You can think of this as that in have the function `file.open()` for which you need to specify a file location, (`file.open(/home/joel/iris.csv`). In R this looks similar, it is `read.csv('/home/joel/iris.csv')`, <!--need to write in windows paths...--> so it is pretty much the same, slightly different words are used and you type them in instead of clicking your way to them.

When you open a file in Excel, it will immediately display the content in the window. Likewise, the R console will display the information of the data set when you read it in. This sample data set that we are using for this class describes the length and width of sepals and petals for three species of iris flowers.

```{r}
read_csv('/home/joel/iris.csv') # need to dry run this with windows path names...
```


If we want to calculate something in Excel, we would highlight the column and then click mean... <!-- I actually don't have Excel and don't know how to do this, will check tomorrow... --> In R we first give the data a nick name where it is stored, so instead of printing out to console, these values are stored in this R session and we can access it by this name `iris`, (technically we say that we have assigned it to variable `iris`).

```{r}
iris <- read_csv('/home/joel/iris.csv')
```

Now we can simply ask to calculate the mean of the data frame `iris`, column `petal_length`:

```{r}
mean(iris$petal_length)
```

If we want to know more than just the mean, the useful thing with R, is that we don't have to calculate these things one by one, but we can actually get an overview of all the columns by asking R to provide a summary of `iris`.

```{r}
summary(iris)
```

You can already see how it will save you time to use R instead of typing these calculations separately in Excel.
 
## RStudio
Before we continue, we are going to switch from using the R console, to using an interface called RStudio. RStudio includes the R console, but also many other convenient functionalities, which makes it easier to get started and to work with R. When you launch RStudio, you will see four panels:
- The console is the same as what we have been using so far. The advantage with using the console within RStudio is that it interact with the other panels.
- So, if I read in the iris data we were working with previously, we can view it in the console by typing `iris`, just like before, or we can also view the `iris` variable in our environment tab, which shows it to us in a spreadsheet or table format.
- This panel shows the files in the current directory, any plots we might make later, and also the documentation, which we accessed earlier by typing `?` in front of a function. Here, the documentation is formatted in a way that is easier to read and also provides links to the related sections.
- Finally we have the text editor panel. This is where we can write scripts, i.e. putting several commands of code together and saving them as a text document so that they are accessible for later and so that we can execute them all at once by running the script instead of typing them in one by one.

So if I create a script with some of the commands you saw earlier, I can save them all as a text file and then run the entire script by clicking the run button, which executes commands in the console. We will use this text editor to explore how to make plots in R.

## Plots
In R, it is straightforward to make explore your data by creating nice looking plots. E.g. to make a scatter plot, we first tell R that we want to make a plot of the `iris` data frame, and we want the aesthetics of this plot to be that `sepal_length` is on the x axis and `sepal_width` is on the y-axis. Finally, we specify that we want this to be a plot of points, i.e. a scatter plot.

```{r}
ggplot(iris, aes(x=sepal_length, y=sepal_width)) +
    geom_point()
```

This plots shows up in the plot panel in RStudio, which is convenient instead of having it show up as a separate window. You can already see that there seems to be at least some structure to the data. There is one cluster of points up the left corner and at least one in the lower right corner. Hmmmm, I wonder if these correspond to the different species of flowers... Let's find out, by coloring the points according to which species they are.

```{r}
ggplot(iris, aes(x=sepal_length, y=sepal_width, color=species)) +
    geom_point()
```

Likewise, it would be really easy to make a histogram of the petal_length and color it according to the species.

```{r}
ggplot(iris, aes(x=petal_length, fill=species)) +
    geom_histogram()
```

And we could get fancier by simply instructing R to split this plot in vertically stacked facets, or subplots, with one species in each facet.

```{r}
ggplot(iris, aes(x=petal_length, fill=species)) +
    geom_histogram() +
    facet_wrap(~ species, dir='v')
```

One last example If you don't have a clear idea of what you are looking for in a data set, maybe you are exploring publicly available data that you have not generated yourself, then it can be useful to visualize the relationships between all the variables to get an overview of the data.

```{r}
ggpairs(iris, aes(colour = species))
```

This plot is a bit overwhelming, and the purpose here is not to produce a publication ready figure. You can see that many of the labels are overlapping and not everything fits in the plotting window. We can tweak these properties, which we will get into later in the course. But even in its slightly rough form, this is a powerful data set overview for your own analyses.

Hopefully, these examples have giving you a idea of how simple and powerful it is to use R for you exploratory data analyses. In a few lines of codes we have made some really nice plots, some of which are not even imaginable to create in Excel.

## Saving data
OK, now you should have a somewhat of an idea of how to generate program... But now that I am done with my analysis, how do I save it? First, what do we want to save? Definitely the plots, those are important. And remember that we said one of the biggest advantages over graphical software is that we have access to all the commands we typed in, and we can save them as an instruction manual for how to make these plots.

Scripts are powerful for automation, but it is still a little bit messy in terms of saving you data, since we will keep the code in one text file and all the output graphs will be saved as separate images. It would not be clear exactly which part of the text file generated what images unless we added notes about this manually. Instead, it would be great if we could keep this all together, in sort of a notebook format... Luckily, there is something called the R Notebook (go to New -> R notebook), which allows us to do exactly that!

# The R Notebook & R Markdown
In the R Notebook, we are writing in a format called R Markdown, which allows us to combine R code, as the one we were just writing, with the Markdown text format, which allows us to use certain characters to specify headings, bullet points, quotations and even citations. A simple example of how to write in Markdown is to use a single asterisk or underscore to emphasize text _emphasis_ and two asterisks or underscores to strongly emphasize text **strong emphasis**. These will show up as italics and bold typeface when we convert this document to pdf or html, which we will do soon. If you have been writing on online forums, or popular chat services, such as whatsapp, you might already be familiar with this style of writing. In case you haven't seen it before, you have just learnt something about whatsapp in your theoretical ecology class...

R Markdown can easily be converted into html and pdf documents with figures and professional typesetting. There are actually many academic papers that are written entirely in R Markdown and it is great for assignments or reports: I have used this myself for some of my progress updates to my supervisor. Since R Markdown converts to html, it is also easy to publish simple good-looking websites in it, for example the syllabus website for this course is made via an R Markdown template that Luke set up.

Let's try to convert this new document. First, let's go through it and see what we expect the output to include. First we see this intro section here, this is where you specify the title of your document, what kind of output you want, and a few other things that we will try later. This is called the yaml-block, but that's not important for now. Then we have a heading, a link some bold text, and a few code blocks. OK, let's see what this looks like. To create the output document, we poetically say that we will knit our R Markdown into the HTML document. Luckily, it is much simpler than actually knitting something, just press this button here and the new document will be created.

As you can see, the title showed up as we would expect, the lines with pound sign(s) in front of them were converted into headers and we can see both the code and its output! So the plots are generated directly in the report without us having to cut and paste images! If we change something in the code, we don't have to find the new images and paste it in again, the correct one will appear right in your code. E.g. if we realize that we actually used the wrong data set for the plot, and we want to plot `cars` instead, we just change `pressure` to `cars` and then click stitch again, done!

Furthermore, if we want to change the style of our output document, it is quite easy to do so. Let's add a subheading first, then to keep track of things we want a table of contents, _knit_. Now we realize that we want to include numbers in the report to keep with the departmental guidelines, _knit_. We could alter the style of our report by adding a theme, _knit_. And finally we remember that we need to hand in our assignments as pdf-files, so let's create a pdf instead of a html-document, _remove themee and knit_.

```yaml
---
title: "HTML output demo"
output:
  html_document:
    toc: true
    number_section: true
    theme: united
---
```
## R Notebook interactivity
That explains what R markdown is and how we generate reports from it. But how do we work with it interactively? Well it is actually quite simple. Execute the chunks of R code by pressing this little green arrow or the corresponding keyboard shortcut `Shift+Ctrl+Enter`. The output appears right under the code block. This is a great way to perform exploratory data analysis, since you can do your analysis and write comments and conclusions write under it in the same document. To get familiar with this workflow, I will go type in some of the commands that we went through earlier and write comments while working with them. A powerful feature of this workflow, is that there is no extra time needed for code documentation and note-taking, you're doing your analyses and taking notes at the same time, it is great for both taking notes at lectures and to have as a reference when you return to your code in the future.

_Show some examples depending on time left..._

Hopefully, this has given you an idea of how powerful and time-saving R can be for your data analysis, and how we will work with it in this class using the R Notebook. The first assignment will be available on blackboard today, and it is includes a few questions about RStudio and R Markdown. 1 / 4 marks on this assignment is to fill in a survey about your background knowledge. This is so that we can adjust the pace and content of the lectures and to divide you into groups accordingly for the class project later this fall. Please take 10 min to do so now by going to this page (send page to everyone's computer via the teaching software), or if you have to run, you can complete it at home.


# Misc notes (not in lecture at the moment)
Left out on purpose
- Comments in R and Markdown
- Importing packages
- 

<!-- Maybe save this for last if there is time -->
As an aside, we can learn more about Markdown, and text vs binary formats in general. Let's contrast writing in Markdown with writing in a word processor, such as MS Word or Google Docs. In the word processor, the text you are writing is stored on the computer in a binary source format, which means that it looks like gibberish to humans and only the program you used to create the document can read it again. If you change a text section to boldface, some part of this gibberish will change and look like slightly different gibberish, but there is no way you can tell that you just made that text bold. If the company decides to stop making their software or upgrades to a new version, there is no guarantee that you will be able to access your old documents. Likewise, if you change between platforms, such as windows and Mac, documents might not be displayed the same way.

A simpler solution that guarantees that you will be able to read the documents you have created yourself for as long time into the future, is to use what is called a markup language. Instead of binary codes, markup languages uses characters to mark text for formatting by special software. For example in html source code, tags are used to markup text: `<strong>bold text here</strong>`. A browser, such as Firefox, will interpret this source code and display the text with a heavier font weight. You can also read the source yourself with _any_ text editor, and although the visual formatting is not applied, the tags are there so that it is easy for you to convert it to another format or for someone else to build a browser that can read these same html tags. And since the source code is readable by humans, you don't run the chance of losing access to your own work any time soon and it is easy for other people who might not be able to afford the same software you own to also read your work. 

<!-- Also if there is time-->
Show example with my RNA-seq report I made previously.
